import time
import tracemalloc
import random
import os, sys

sys.path.append(os.path.abspath(os.path.join(__file__, '..', '..')))

from model.entrega import Entrega
from model.caminhao import Caminhao
from model.centro_distribuicao import CentroDistribuicao
from model.grafoMatrizAdjacencia import GrafoMatrizAdjacencia
from controller.roteirizador import Roteirizador

def gerar_entregas(qtd: int) -> list:
    """
    Gera uma lista de objetos Entrega com dados aleat√≥rios.

    Args:
        qtd (int): Quantidade de entregas a serem geradas.

    Returns:
        list: Lista de objetos Entrega.
    """
    destinos = [
        "Salvador", "Fortaleza", "Manaus", "Porto Alegre", "Curitiba",
        "Rio de Janeiro", "Vit√≥ria", "Goi√¢nia", "Campo Grande", "Natal"
    ]
    entregas = []
    for i in range(qtd):
        destino = random.choice(destinos)
        peso = random.randint(500, 3000)
        prazo = random.randint(8, 24)
        entregas.append(Entrega(f"E{i:03d}", destino, peso, prazo))
    return entregas


def preparar_centros() -> list:
    """
    Cria centros de distribui√ß√£o com caminh√µes alocados.

    Returns:
        list: Lista de objetos CentroDistribuicao com caminh√µes.
    """
    cidades = ["Bel√©m", "Recife", "Bras√≠lia", "S√£o Paulo", "Florian√≥polis"]
    centros = []
    for cidade in cidades:
        centro = CentroDistribuicao(cidade)
        # Adiciona 4 caminh√µes por centro
        for j in range(10):
            cam = Caminhao(f"{cidade[:2]}-{j+1}", 6000, 22)
            centro.adicionar_caminhao(cam)
        centros.append(centro)
    return centros


def preparar_grafo_matriz() -> GrafoMatrizAdjacencia:
    """
    Cria um grafo com a representa√ß√£o de matriz de adjac√™ncia para as conex√µes.
    """
    cidades = [
        "Bel√©m", "Recife", "Bras√≠lia", "S√£o Paulo", "Florian√≥polis",
        "Manaus", "Fortaleza", "Porto Alegre", "Curitiba", "Rio de Janeiro", 
        "Vit√≥ria", "Goi√¢nia", "Campo Grande", "Natal", "Salvador"
    ]
    grafo = GrafoMatrizAdjacencia(cidades)
    # Adiciona as arestas ao grafo
    grafo.adicionar_aresta("Bel√©m", "Manaus", 10)
    grafo.adicionar_aresta("Recife", "Fortaleza", 5)
    grafo.adicionar_aresta("Recife", "Salvador", 6)
    grafo.adicionar_aresta("Bras√≠lia", "Salvador", 7)
    grafo.adicionar_aresta("S√£o Paulo", "Curitiba", 4)
    grafo.adicionar_aresta("Florian√≥polis", "Curitiba", 3)
    grafo.adicionar_aresta("Florian√≥polis", "Porto Alegre", 5)
    grafo.adicionar_aresta("S√£o Paulo", "Porto Alegre", 7)
    grafo.adicionar_aresta("Bras√≠lia", "Goi√¢nia", 4)
    grafo.adicionar_aresta("Bras√≠lia", "Campo Grande", 9)
    grafo.adicionar_aresta("S√£o Paulo", "Rio de Janeiro", 6)
    grafo.adicionar_aresta("S√£o Paulo", "Vit√≥ria", 8)
    grafo.adicionar_aresta("Recife", "Natal", 4)
    grafo.adicionar_aresta("Bel√©m", "Bras√≠lia", 12)
    grafo.adicionar_aresta("Recife", "Bras√≠lia", 10)
    grafo.adicionar_aresta("Bras√≠lia", "S√£o Paulo", 8)
    grafo.adicionar_aresta("S√£o Paulo", "Florian√≥polis", 6)

    return grafo


def testar_desempenho(qtd_entregas: int, mostrar_erros: bool=False) -> tuple[int, int]:
    """
    Executa um teste de desempenho com 100 entregas, medindo tempo e uso de mem√≥ria.

    O teste simula centros, entregas, e o grafo de conex√µes. Roda o algoritmo de roteiriza√ß√£o
    e imprime os resultados de desempenho e aloca√ß√£o de entregas.
    """
    centros = preparar_centros()
    entregas = gerar_entregas(qtd_entregas)
    grafo = preparar_grafo_matriz()

    tracemalloc.start()
    inicio = time.perf_counter()

    roteirizador = Roteirizador(centros, entregas, grafo)
    resultado = roteirizador.alocar_entregas()

    fim = time.perf_counter()
    memoria_atual, memoria_pico = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    erros = [rota["erro"] for rota in resultado if "erro" in rota]
    tot_erros = len(erros)
    tot_sucessos = qtd_entregas - len(erros)

    print(f"\nüìù Roteiriza√ß√£o conclu√≠da para {qtd_entregas} entregas.")
    print(f"‚è±Ô∏è Tempo de execu√ß√£o: {fim - inicio:.4f} segundos")
    print(f"üíæ Uso de mem√≥ria atual: {memoria_atual / 1024:.2f} KB")
    print(f"üìà Pico de mem√≥ria: {memoria_pico / 1024:.2f} KB")
    print(f"‚úÖ Entregas com sucesso: {tot_sucessos} | ({tot_sucessos/qtd_entregas:.2%})")
    print(f"‚ùå Entregas com erro: {tot_erros} | ({tot_erros/qtd_entregas:.2%}\n")

    if mostrar_erros and erros:
        print(*[rota["erro"] + " com ID " + rota["entrega"].id for rota in resultado if "erro" in rota], sep="\n")

    return tot_sucessos, tot_erros


if __name__ == "__main__":
    for qtd in [10, 50, 100, 200]:
        testar_desempenho(qtd)
